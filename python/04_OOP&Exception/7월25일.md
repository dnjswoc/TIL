# 7월 25일 수업 내용 정리
## 상속
- 상속(Inheritance) : 기존 클래스의 속성과 메서드를 물려받아 새로운 하위 클래스를 생성하는 것
- 상속이 필요한 이유
    1. 코드 재사용
        - 상속을 통해 기존 클래스의 속성과 매서드를 재사용할 수 있음
        - 새로운 클래스를 작성할 때 기존 클래스의 기능을 그대로 활용할 수 있으며, 중복된 코드를 줄일 수 있음
    2. 계층 구조
        - 상속을 통해 클래스들 간의 계층 구조를 형성할 수 있음
        - 부모 클래스와 자식 클래스 간의 관계를 표현하고, 더 구체적인 클래스를 만들 수 있음
    3. 유지 보수의 용이성
        - 상속을 통해 기존 클래스의 수정이 필요한 경우, 해당 클래스만 수정하면 되므로 유지 보수가 용이해짐
        - 코드의 일관성을 유지하고, 수정이 필요한 범위를 최소화할 수 있음
### 클래스 상속
- 상속 없이 구현하는 경우
    - 학생/교수 정보를 별도로 표현하기 어려움
    - 교수/학생 클래스로 분리했지만 메서드가 중복으로 정의될 수 있음

### 다중 상속
- 다중 상속
    - 둘 이상의 상위 클래스로부터 여러 행동이나 특징을 상속받을 수 있는 것
    - 상속받은 모든 클래스의 요소를 활용 가능함
    - 중복된 속성이나 메서드가 있는 경우 **상속 순서에 의해 결정**됨
- 다중 상속 예시
- 다이아몬드 문제(Teh diamond problem)
    - 두 클래스 B와 C가 A에서 상속되고 클래스 D가 B와 C 모두에서 상속될 때 발생하는 모호함
    - B와 C가 재정의한 메서드가 A에 있고 D가 이를 재정의하지 않은 경우라면
    - D는 B의 메서드 중 어떤 버전을 상속하는가? 아니면 C의 메서드 버전을 상속하는가?
- python에서의 해결책
    - MRO(Method Resolution Order) 알고리즘을 사용하여 클래스 목록을 생성
    - 부모 클래스로부터 상속된 속성들의 검색을 깊이 우선으로, 왼쪽에서 오른쪽으로, 계층 구조에서 겹치는 같은 클래스를 두 번 검색하지 않음
    - 그래서, 속성이 D에서 발견되지 않으면, B에서 찾고, 거기에서도 발견되지 않으면, C에서 찾고, 이런 식으로 진행됨
- MRO(Method Resolution Order) : 메서드 결정 순서
- super() : 부모 클래스 객체를 반환하는 내장 함수(다중 상속 시 MRO를 기반으로 현재 클래스가 상속하는 모든 부모 클래스 중 다음에 호출될 메서드를 결정하여 자동으로 호출)


## 에러와 예외

### 디버깅


### 에러


### 예외


## 예외 처리
### try & except
### 복수 예외 처리
### else & finally


## 참고
### 예외 처리 주의사항
### 예외 객체 다루기
### EAFP & LBYL