# 7월 16일 수업 내용 정리
## Data Types
- 값의 종류와 그 값에 적용 가능한 연산과 동작을 결정하는 속성
- 데이터 타입 분류
    - Numeric Types : int, float, complex(복소수)
    - Text Sequence Type : str
    - Sequence Type : list, tuple, rnage
    - Non-sequence Types : set, dict
    - 기타 : Boolean, None, Fuctions
- 데이터 타입이 필요한 이유
    - 값들을 구분하고, 어떻게 다뤄야 하는지를 알 수 있음
    - 요리 재료마다 특정한 도구가 필요하듯이 각 데이터 타입 값들도 각자에게 적합한 도구를 가짐
    - 타입을 명시적으로 지정하면 코드를 읽는 사람이 변수의 의도를 더 쉽게 이해할 수 있고, 잘못된 데이터 타입으로 인한 오류를 미리 예방

## Numeric Types
### int
- int(정수 자료형) : 정수를 표현하는 자료형
- 진수 표현
    - 2진수(binary) : 0b
    - 8진수(octal) : 0o
    - 16진수(hexadecimal) : 0x

### float
- float(실수 자료형) : 실수를 표현하는 자료형(프로그래밍 언어에서 float는 실수에 대한 **근삿값**)
- 유한 정밀도
    - 컴퓨터 메모리 용량이 한정돼 있고, 한 숫자에 대해 저장하는 용량이 제한 됨
    - 0.6666666666과 1.6666667은 제한된 양의 메모리에 저장할 수 있는 2/3과 5/3에 가장 가까운 값
- 실수 연산 시 주의사항
    - 컴퓨터는 2진수를 사용, 사람은 10진법을 사용
    - 이때 10진수 0.1은 2진수로 표현하면 무한대로 반복됨
    - 무한대 숫자를 그대로 저장할 수 없어서 사람이 사용하는 10진법의 근삿값만 표시
    - 0.1의 경우 정확히 동일하지 않음
    - 이 과정에서 예상치 못한 결과가 나타남
    - 이런 증상을 Floating point rounding error(부동소수점 에러)라고 함
- 부동소수점 에러
    - 컴퓨터가 실수를 표현하는 방식으로 인해 발생하는 작은 오차
    - 원인 : 실수를 2진수로 변환하는 과정에서 발생하는 근사치 표현
- 부동소수점 에러 해결책
    - 대표적으로 decimal 모듈을 사용해 부동소수점 연산의 정확성을 보장하는 방법
    - 이외에도 다양한 해결 방법이 존재
- 지수 표현 방식 : e 또는 E를 사용한 지수 표현

## Sequence Types
- 여러 개의 값들을 **순서대로 나열**하여 저장하는 자료형(str, list, tuple, range)
- Sequence Types 특징
    1. 순서(Sequence) : 값들이 순서대로 저장(정렬X)
    2. 인덱싱(Indexing) : 각 값에 고유한 인덱스(번호)를 가지고 있으며, 인덱스를 사용하여 특정 위치의 값을 선택하거나 수정할 수 있음
    3. 슬라이싱(Slicing) : 인덱스 범위를 조절해 부분적인 값을 추출할 수 있음
    4. 길이(Length) : len()함수를 사용하여 저장된 값의 개수(길이)를 구할 수 있음
    5. 반복(Iteration) : 반복문을 사용하여 지정된 값들을 반복적으로 처리할 수 있음
### str
- str(문자열) : 문자들의 순서가 있는 변경 불가능한 시퀀스 자료형
- 문자열 표현
    - 문자열은 단일 문자나 여러 문자의 조합으로 이루어짐
    - 작은따옴표(') 또는 큰따옴표(")로 감싸서 표현
- 중첩 따옴표 : 따옴표 안에 따옴표를 표현할 경우
    - 작은따옴표가 들어 있는 경우는 큰따옴표로 문자열 생성
    - 큰따옴표가 들어 있는 경우는 작은따옴표로 문자열 생성
- Escape sequence
    - 역슬래시(backslash, \\ )뒤에 특정 문자가 와서 특수한 기능을 하는 문자 조합
    - python의 일반적인 문법 규칙을 잠시 탈출한다는 의미
- String Interpolation : 문자열 내에 변수나 표현식을 삽입하는 방법
- f-string
    - 문자열에 f 또는 F 접두어를 붙이고 표현식을 {expression}로 작성하는 문법
    - 문자열에 python 표현식의 값을 삽입할 수 있음
- 인덱스(index) : 시퀀스 내의 값들에 대한 고유한 번호로, 각 값의 위치를 식별하는 데 사용되는 숫자
- 슬라이싱(slicing) : 시퀀스의 일부분을 선택하여 추출하는 작업(시작 인덱스와 끝 인덱스를 지정하여 해당 범위의 값을 포함하는 새로운 시퀀스를 생성)
- 문자열은 불변(변경 불가)

### list
- list(리스트) : 여러 개의 값을 순서대로 저장하는 변경 가능한 시퀀스 자료형
- 리스트 표현
    - 0개 이상의 객체를 포함하며 데이터 목록을 저장
    - 대괄호([])로 표기
    - 데이터는 어떤 자료형도 저장할 수 있음
- 리스트는 가변(변경 가능)

### tuple
- tuple(튜플) : 여러 개의 값을 순서대로 저장하는 변경 불가능한 시퀀스 자료형
- 튜플 표현
    - 0개 이상의 객체를 포함하며 데이터 목록을 저장
    - 소괄호(())로 표기
    - 데이터는 어떤 자료형도 저장할 수 있음
- 튜플은 불변(변경 불가)
- 튜플은 어디에 쓰일까?
    - 튜플의 불변 특성을 사용한 안전하게 여러 개의 값을 전달, 그룹화, 다중 할당 등(**개발자가 직접 사용하기 보다 'python 내부 동작'에서 주로 사용됨**)


### range
- range : 연속된 정수 시퀀스를 생성하는 변경 불가능한 자료형
- range 표현
    - range(시작 값, 끝 값, 증가 값)
    - range(n) : 0부터 n-1까지의 숫자 시퀀스
    - range(n, m) : n부터 m-1까지의 숫자 시퀀스
- range 특징
    - 증가 값이 없으면 1씩 증가
    - 증가 값이 음수이면 감소/증가 값이 양수이면 증가
    - 증가 값이 0이면 에러
    - 증가 값이 음수이면 시작 값이 끝 값보다 커야 함
    - 증가 값이 양수이면 시작 값이 끝 값보다 작아야 함
- range 표현 : 주로 반복문과 함께 사용 예정

## Non-sequence Types
### dict
- dict(딕셔너리) : key-value 쌍으로 이루어진 순서와 중복이 없는 변경 가능한 자료형
- 딕셔너리 표현
    - key는 변경 불가능한 자료형만 사용 가능(str, int, float, tuple, range ...)
    - value는 모든 자료형 사용 가능
    - 중괄호({})로 표기
- 딕셔너리 사용 : key를 통해 value에 접근

### set
- set(세트) : 순서와 중복이 없는 변경 가능한 자료형
- 세트 표현
    - 수학에서의 집합과 동일한 연산 처리 가능
    - 중괄호({})로 표기
- 세트의 집합 연산

## Other Types
### None
- python에서 '값이 없음'을 표현하는 자료형
- None 표현

### Boolean
- 참(True)과 거짓(False)을 표현하는 자료형
- 불리언 표현
    - 비교/논리 연산의 평가 결과로 사용됨
    - 주로 조건/반복문과 함께 사용

## Collection
- Collection : 여러 개의 항목 또는 요소를 담는 자료 구조(str, list, tuple, set, dict)
- 컬렉션 정리
- 불변과 가변의 차이



## 형변환(Type Conversion)
- 한 데이터 타입을 다른 데이터 타입으로 변환하는 과정(암시적 형변환/명시적 형변환)
### 암시적 형변환
- 암시적 형변환(Implicit Type conversion) : python이 자동으로 수행하는 형변환
- 암시적 형변화 예시
    - 정수와 실수의 연산에서 정수가 실수로 변환됨
    - Boolean과 Numeric Type에서만 가능

### 명시적 형변환
- 명시적 형변환(Explicit Type conversion) : 프로그래머가 직접 지정하는 형변환(암시적 형변환이 아닌 경우를 모두 포함)
- 명시적 형변환 예시
    - str -> int : 형식에 맞는 숫자만 가능
    - int -> str : 모두 가능
- 컬렉션 간 형변환 정리

## 연산자
### 산술 연산자
- +, -(뺄셈), *, /, //, %, **, -(음수 부호)

### 복합 연산자
- 연산과 할당이 함께 이루어짐
- +=, -=, %=, /=, //=, %=, **=

### 비교 연산자
- <, <=, >, >=, ==, !=, is, is not
- is 비교 연산자
    - 메모리 내에서 같은 객체를 참조하는지 확인
    - ==는 동등성(equality), **is**는 식별성(identity)
    - 값을 비교하는 ==와 다름

### 논리 연산자
- and(논리곱), or(논리합), not(논리부정, 단일 피연산자를 부정)
- 비교 연산자와 함께 사용 가능

### 단축평가
- 논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작
- 단축평가 예시
- 단축평가 동작
    - and, or
- 단축평가 이유 : 코드 실행을 최적화하고, 불필요한 연산을 피할 수 있도록 함

### 멤버십 연산자
- 특정 값이 시퀀스나 다른 컬렉션에 속하는지 여부를 확인
- in, not in

### 시퀀스형 연산자
- +와 *는 시퀀스 간 연산에서 산술 연산자일때와 다른 역할을 가짐
- '+' : 결합 연산자
- '*' : 반복 연산자
- 연산자 우선순위 정리











---
- python은 다양한 구조의 데이터를 받을 수 있는 장점이 있고, 다양한 구조의 데이터를 받을 때 메모리 할당도 다양하게 되면서 데이터 검색 속도가 느려진다.

## Sequence Types
### str
- 변경 불가능

### list
- 변경 가능(값을 바꿀 때 메모리 주소를 변경)
- 데이터 자료에 제한이 없다
    - 빈 리스트, 리스트 안에 요소로 리스트가 존재 가능
- Sequence Type의 기능을 모두 사용 가능하다.(인덱싱, 슬라이싱, 등)
- 현실의 내용을 컴퓨터로 가져오기 위해 사용(1차원 배열, 2차원 배열, 3차원 배열)
- 여러 가지 data type을 항목(item)으로 가질 수 있다.
- 중첩 구조를 사용하여 1차원, 2차원, ... , n차원 배열 구조로 구현할 수 있다.

### tuple
- list와 똑같지만 변경이 불가능하다
- 소괄호로 표기
- 요소가 하나일 때 아래와 같이 표현
```python
my_tuple_2 = (1, )
```
- tuple은 어딘가에 안전하게 저장하기 위해 사용(그룹화, 다중 할당 등)하므로 개발자가 직접 사용하기 보다 'python 내부 동작'에서 주로 사용된다.
- python은 쉼표를 tuple 생성자로 사용하므로 괄호는 생략 가능하다.

### range
- 연속된 정수 시퀀스를 생성하는 변경 불가능한 자료형
- 함수 형태로 되어있다.
- ex.
    - range(시작 값, 끝 값, 증가 값), default
    - range(n) : 0부터 n-1까지의 숫자의 시퀀스
    - range(n, m) : n부터 m-1까지의 숫자 시퀀스
- 증가 값이 없으면 1씩 증가
- 증가 값이 음수이면 감소, 양수이면 증가
- 증가 값이 0이면 error
- 증가 값이 음수이면 시작 값이 끝 값보다 커야 함
- 증가 값이 양수이면 시작 값이 끝 값보다 작아야 함
- 정해진 횟수만큼 프로그램 반복

## Non-sequence types(순서가 없음)
### dict
- 딕셔너리로 key-value 쌍으로 이루어진 순서와 중복이 없는 변경 가능한 자료형
- key는 변경 불가능한 자료형만 사용 가능(str, int, float, tuple, range, list 등등)
- value는 모든 자료형 사용 가능
- 중괄호로 표기
- 딕셔너리는 키에 접근해 값을 얻어냄

### set
- 순서와 중복이 없는 변경 가능한 자료형
- 수학에서의 집합과 동일한 연산 처리 가능
- 증괄호로 표기
- ex. my_set_1 = set()
- 합집합, 차집합, 교집합
```python
my_set_1 = {1, 2, 3}
my_set_2 = {3, 6, 9}
# 합집합
print(my_set_1 | my_set_2) # {1, 2, 3, 6, 9}
# 차집합
print(my_set_1 - my_set_2) # {1, 2}
# 교집합
print(my_set_1 & my_set_2) # {3}
```
- 중복을 없앨 수 있는 장점이 있지만, 순서가 없어질 수 있는 단점도 있다.

## Other Types
### None
- python에서 '값이 없음'을 표현하는 자료형
- 첫 N을 대문자로 사용해야 한다.

### Boolean
- 참과 거짓을 표현하는 자료형
- 비교/논리 연산의 평가 결과로 사용됨
- 주로 조건/반복문과 함께 사용
- True, False 첫 글자를 대문자로 사용해야 한다.
- 0은 False로 보고, 0을 제외한 정수들은 True로 본다.
- ""(공백)은 False로 보고, 공백은 제외한 문자열은 True로 본다.

### Collection
- 여러 개의 항목 또는 요소를 담는 자료 구조
- range는 collection에서 빠짐

## Type Conversion
### 암시적 형변환
- python이 자동으로 수행하는 형변환
- 정수와 실수의 연산에서 정수가 실수로 변환됨
- Boolean과 Numeric Type에서만 가능(True :1, False : 0)
- 암시적 형변환이 일어나지 않도록 코드를 짜는 것이 좋다.
### 명시적 형변환
- 프로그래머가 직접 지정하는 형변환, 암시적 형변환이 아닌 모든 경우
- str -> int : 형식에 맞는 숫자만 가능(str형태의 소수를 int로 받을 수 없다)
- int -> str : 모두 가능
- 값을 입력하면서 구분을 위한 입력인지 계산을 위한 입력인지 고민하고 형을 변환한다.

## 연산자
### 산술 연산자
- +, -, *, /, //, %, ** 등
### 복합 연산자
- 연산과 할당이 함께 이루어짐
- +=, -=, *=, /=, //=, %=, **= 등
### 비교 연산자
- <, >, <=, >=, ==, !=, is(같음), is not(같지 않음)
- is 비교 연산자
    - 메모리 내에서 같은 객체를 참조하는지 확인
    - ==는 동등성(equality), is는 식별성(identity) 따라서 is는 레퍼런스(주소)도 비교한다.
### 논리 연산자
- and : 두 피연산자가 모두 True인 경우에만
- or : 
- not : 
### 단축 평가
- 논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작
```python
vowels = 'aeiou'

print(('a' and 'b') in vowels)  # str값은 True로 나오고 'b'가 뱉어진다. -> False
print(('b' and 'a') in vowels)  # 이 경우에는 'a'가 뱉어지므로 -> True

print(3 and 5)  # 두 숫자는 True 값이므로 -> True
print(3 and 0)  # 0은 False 이므로 -> False
print(0 and 3)  # 앞에 False가 나왔으므로 단축평가
print(0 and 0)  # 단축평가

print(5 or 3)  # 이미 True가 나왔으므로 단축평가가 일어난다.
print(3 or 0)  # 이미 True가 나왔으므로 단축평가가 일어난다.
print(0 or 3)  # 뒤에 True가 나왔으므로 단축평가가 일어나지 않고, 3이 출력된다.
print(0 or 0)  # 뒤 0까지 봐야하므로 단축평가가 일어나지 않는다.
```
- 단축평가의 이유 : 코드 실행을 최적화하고, 불필요한 연산을 피할 수 있도록 함
### 멤버십 연산자
- 특정 값이 시퀀스나 다른 컬렉션에 속하는지 여부를 확인
- in : 
- not in : 
### 시퀀스형 연산자
- +와 *는 시퀀스 간 연산에서 산술 연산자일때와 다른 역할을 가짐