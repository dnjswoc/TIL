# 7월 16일 수업 내용 정리
- python은 다양한 구조의 데이터를 받을 수 있는 장점이 있고, 다양한 구조의 데이터를 받을 때 메모리 할당도 다양하게 되면서 데이터 검색 속도가 느려진다.

## Sequence Types
### str
- 변경 불가능

### list
- 변경 가능(값을 바꿀 때 메모리 주소를 변경)
- 데이터 자료에 제한이 없다
    - 빈 리스트, 리스트 안에 요소로 리스트가 존재 가능
- Sequence Type의 기능을 모두 사용 가능하다.(인덱싱, 슬라이싱, 등)
- 현실의 내용을 컴퓨터로 가져오기 위해 사용(1차원 배열, 2차원 배열, 3차원 배열)
- 여러 가지 data type을 항목(item)으로 가질 수 있다.
- 중첩 구조를 사용하여 1차원, 2차원, ... , n차원 배열 구조로 구현할 수 있다.

### tuple
- list와 똑같지만 변경이 불가능하다
- 소괄호로 표기
- 요소가 하나일 때 아래와 같이 표현
```python
my_tuple_2 = (1, )
```
- tuple은 어딘가에 안전하게 저장하기 위해 사용(그룹화, 다중 할당 등)하므로 개발자가 직접 사용하기 보다 'python 내부 동작'에서 주로 사용된다.
- python은 쉼표를 tuple 생성자로 사용하므로 괄호는 생략 가능하다.

### range
- 연속된 정수 시퀀스를 생성하는 변경 불가능한 자료형
- 함수 형태로 되어있다.
- ex.
    - range(시작 값, 끝 값, 증가 값), default
    - range(n) : 0부터 n-1까지의 숫자의 시퀀스
    - range(n, m) : n부터 m-1까지의 숫자 시퀀스
- 증가 값이 없으면 1씩 증가
- 증가 값이 음수이면 감소, 양수이면 증가
- 증가 값이 0이면 error
- 증가 값이 음수이면 시작 값이 끝 값보다 커야 함
- 증가 값이 양수이면 시작 값이 끝 값보다 작아야 함
- 정해진 횟수만큼 프로그램 반복

## Non-sequence types(순서가 없음)
### dict
- 딕셔너리로 key-value 쌍으로 이루어진 순서와 중복이 없는 변경 가능한 자료형
- key는 변경 불가능한 자료형만 사용 가능(str, int, float, tuple, range, list 등등)
- value는 모든 자료형 사용 가능
- 중괄호로 표기
- 딕셔너리는 키에 접근해 값을 얻어냄

### set
- 순서와 중복이 없는 변경 가능한 자료형
- 수학에서의 집합과 동일한 연산 처리 가능
- 증괄호로 표기
- ex. my_set_1 = set()
- 합집합, 차집합, 교집합
```python
my_set_1 = {1, 2, 3}
my_set_2 = {3, 6, 9}
# 합집합
print(my_set_1 | my_set_2) # {1, 2, 3, 6, 9}
# 차집합
print(my_set_1 - my_set_2) # {1, 2}
# 교집합
print(my_set_1 & my_set_2) # {3}
```
- 중복을 없앨 수 있는 장점이 있지만, 순서가 없어질 수 있는 단점도 있다.

## Other Types
### None
- python에서 '값이 없음'을 표현하는 자료형
- 첫 N을 대문자로 사용해야 한다.

### Boolean
- 참과 거짓을 표현하는 자료형
- 비교/논리 연산의 평가 결과로 사용됨
- 주로 조건/반복문과 함께 사용
- True, False 첫 글자를 대문자로 사용해야 한다.
- 0은 False로 보고, 0을 제외한 정수들은 True로 본다.
- ""(공백)은 False로 보고, 공백은 제외한 문자열은 True로 본다.

### Collection
- 여러 개의 항목 또는 요소를 담는 자료 구조
- range는 collection에서 빠짐

## Type Conversion
### 암시적 형변환
- python이 자동으로 수행하는 형변환
- 정수와 실수의 연산에서 정수가 실수로 변환됨
- Boolean과 Numeric Type에서만 가능(True :1, False : 0)
- 암시적 형변환이 일어나지 않도록 코드를 짜는 것이 좋다.
### 명시적 형변환
- 프로그래머가 직접 지정하는 형변환, 암시적 형변환이 아닌 모든 경우
- str -> int : 형식에 맞는 숫자만 가능(str형태의 소수를 int로 받을 수 없다)
- int -> str : 모두 가능
- 값을 입력하면서 구분을 위한 입력인지 계산을 위한 입력인지 고민하고 형을 변환한다.

## 연산자
### 산술 연산자
- +, -, *, /, //, %, ** 등
### 복합 연산자
- 연산과 할당이 함께 이루어짐
- +=, -=, *=, /=, //=, %=, **= 등
### 비교 연산자
- <, >, <=, >=, ==, !=, is(같음), is not(같지 않음)
- is 비교 연산자
    - 메모리 내에서 같은 객체를 참조하는지 확인
    - ==는 동등성(equality), is는 식별성(identity) 따라서 is는 레퍼런스(주소)도 비교한다.
### 논리 연산자
- and : 두 피연산자가 모두 True인 경우에만
- or : 
- not : 
### 단축 평가
- 논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작
```python
vowels = 'aeiou'

print(('a' and 'b') in vowels)  # str값은 True로 나오고 'b'가 뱉어진다. -> False
print(('b' and 'a') in vowels)  # 이 경우에는 'a'가 뱉어지므로 -> True

print(3 and 5)  # 두 숫자는 True 값이므로 -> True
print(3 and 0)  # 0은 False 이므로 -> False
print(0 and 3)  # 앞에 False가 나왔으므로 단축평가
print(0 and 0)  # 단축평가

print(5 or 3)  # 이미 True가 나왔으므로 단축평가가 일어난다.
print(3 or 0)  # 이미 True가 나왔으므로 단축평가가 일어난다.
print(0 or 3)  # 뒤에 True가 나왔으므로 단축평가가 일어나지 않고, 3이 출력된다.
print(0 or 0)  # 뒤 0까지 봐야하므로 단축평가가 일어나지 않는다.
```
- 단축평가의 이유 : 코드 실행을 최적화하고, 불필요한 연산을 피할 수 있도록 함
### 멤버십 연산자
- 특정 값이 시퀀스나 다른 컬렉션에 속하는지 여부를 확인
- in : 
- not in : 
### 시퀀스형 연산자
- +와 *는 시퀀스 간 연산에서 산술 연산자일때와 다른 역할을 가짐